<!doctype html>
<html lang="en">

<head data-include="game">
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>Making your first Phaser 3 Game - Part 10</title>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- Phaser -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@v3.80.1/dist/phaser.min.js"></script>
</head>

<body>

    <div id="main" class="py-12 sm:px-6 lg:px-8 h-screen flex items-center justify-center hidden">

        <div id="content">

            <ul id="list" role="list"
                class="divide-y divide-gray-100 overflow-hidden bg-white shadow-sm ring-8 ring-gray-900/4 sm:rounded-xl">

                <li class="px-4 py-5 sm:px-6">
                    <div class="text-center text-3xl font-bold">
                        Would you like to play again?
                    </div>
                </li>

                <li class="px-4 py-5 sm:px-6">
                    <div class="text-center text-3xl font-bold">
                        <a href="/">
                            <button
                                class="rounded-md bg-white m-2 px-3.5 py-2.5 text-3xl font-bold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50 uppercase">
                                Main Menu
                            </button>
                        </a>

                        <a href="/arcade">
                            <button
                                class="rounded-md bg-white m-2 px-3.5 py-2.5 text-3xl font-bold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50 uppercase">
                                Play Again
                            </button>
                        </a>
                    </div>
                </li>
            </ul>
        </div>

    </div>

    <div id="game" class="h-screen"></div>

    <script type="module">
        // Get configs
        import { configModule } from '../../config.js'

        // Setup config data
        let configs = configModule()

        // Get device type
        import { devicesModule } from '../../functions/devices.js'

        // Setup config data
        let device = devicesModule()

        // Get objects
        import { objectsModule } from '../../functions/objects.js'

        // Setup objects data
        let objects = objectsModule()

        // Get preload data
        import { preloadBgModule } from '../../functions/preload/bg.js'
        import { preloadPlayerModule } from '../../functions/preload/player.js'
        import { preloadButtonModule } from '../../functions/preload/button.js'
        import { preloadSfxModule } from '../../functions/preload/sfx.js'
        import { preloadMusicModule } from '../../functions/preload/music.js'
        import { preloadPluginModule } from '../../functions/preload/plugin.js'

        // Setup preload data
        let backgrounds = preloadBgModule()
        let playerSprites = preloadPlayerModule()
        let buttonPreloads = preloadButtonModule()
        let sfxSprites = preloadSfxModule()
        let musics = preloadMusicModule()
        let plugins = preloadPluginModule()

        // Get create data
        import { createPlatformModule } from '../../functions/create/platform.js'
        import { createAnimationModule } from '../../functions/create/animation.js'
        import { createButtonModule, createButtonSoundToggleModule } from '../../functions/create/button.js'
        import { createSelectPlayerSpriteModule, createSetPlayerModule } from '../../functions/create/player.js'
        import { createSetKeyboardKeyModule, createSetJoystickModule } from '../../functions/create/input.js'
        import { createTextModule, createStarModule, createStarChildrenModule, createStartBombModule } from '../../functions/create/object.js'

        // Setup create data
        let platforms = createPlatformModule()
        let animations = createAnimationModule()
        let buttons = createButtonModule()
        let keyboardKeys = createSetKeyboardKeyModule()
        let joystickSpecs = createSetJoystickModule()
        let texts = createTextModule()
        let starSpecs = createStarModule()

        // Setup local data
        let config
        let game

        console.log(configs)
        console.log(device)

        $(document).ready(function () {
            // Include files - https://stackoverflow.com/a/31837264
            $(function () {
                var includes = $('[data-include]')
                $.each(includes, function () {
                    var file = '../templates/head/' + $(this).data('include') + '.html'
                    $(this).load(file)
                })
            })
        })

        // Check assets path
        let assetsPath = "../../assets/"

        window.onload = function () {
            if (device === 'mobile') {
                configs.configMobile.scene = {
                    preload: preload,
                    create: create,
                    update: update
                }
                config = configs.configMobile
                texts.instruction.text = config.instructions
                game = new Phaser.Game(config)
            } else {

                configs.configDesktop.scene = {
                    preload: preload,
                    create: create,
                    update: update
                }
                config = configs.configDesktop
                texts.instruction.text = config.instructions
                game = new Phaser.Game(config)
            }

            function preload() {
                // Backgrounds
                for (const background of backgrounds) {
                    this.load.image(background.key, assetsPath + background.path)
                }

                // Player
                for (const playerSprite of playerSprites) {
                    this.load.spritesheet(playerSprite.key, assetsPath + playerSprite.path, { frameWidth: 32, frameHeight: 48 })
                    objects.playerSpritesArray.push(playerSprite.key) // For displaying sprite in create
                }

                // Buttons
                for (const button of buttonPreloads) {
                    this.load.image(button.key, assetsPath + button.path)
                }

                // Audio

                // https://github.com/phaserjs/examples/blob/master/public/src/audio/HTML5%20Audio/audiosprite.js
                // SFX
                let audioFiles = []
                for (const sfxSprite of sfxSprites.files) {
                    audioFiles.push(assetsPath + sfxSprite.path)
                }
                this.load.audioSprite(sfxSprites.key, assetsPath + sfxSprites.spritePath, audioFiles)

                // Music
                for (const music of musics) {
                    this.load.audio(music.key, [assetsPath + music.path])
                }

                // Plugins
                for (const plugin of plugins) {
                    this.load.plugin(plugin.key, assetsPath + plugin.path, true)
                }
            }

            function create() {
                // A simple background for our game
                objects.sky = this.add.image(400, 300, backgrounds[objects.skyIndex].key)

                // The platforms group contains the ground and the ledges we can jump on
                for (let [index, platform] of platforms.entries()) {
                    objects.platforms[++index] = this.physics.add.staticGroup()
                }

                for (let [index, platform] of platforms.entries()) {
                    // Only get from first
                    if (index === 0) {

                        // Here we create the ground.
                        // Scale it to fit the width of the game (the original sprite is 400x32 in size)
                        for (const ground of platform.grounds) {
                            objects.platforms[objects.platformIndex].create(ground.x, ground.y, ground.key).setScale(2).refreshBody()
                        }

                        // Now let's create some ledges
                        for (const ledge of platform.ledges) {
                            objects.platforms[objects.platformIndex].create(ledge.x, ledge.y, ledge.key)
                        }

                        break
                    }
                }

                // Add buttons
                // Check keys in public\functions\create\button.js for specific buttons

                // Init mute button
                objects.mute = this.add.image(buttons[0].x, buttons[0].y, buttons[0].key).setInteractive()
                objects.mute.on('pointerdown', () => createButtonSoundToggleModule(objects))

                // The player and its settings
                const dude = createSelectPlayerSpriteModule(objects.playerSpritesArray) // Selected sprite

                objects.player = this.physics.add.sprite(100, 450, dude);
                createSetPlayerModule(objects)

                // Our player animations, turning, walking left and walking right.
                for (const animation of animations) {
                    if (animation.frame) {
                        this.anims.create({
                            key: animation.key,
                            frames: [{ key: dude, frame: animation.frame }],
                            frameRate: 20
                        })
                    } else {
                        this.anims.create({
                            key: animation.key,
                            frames: this.anims.generateFrameNumbers(dude, { start: animation.start, end: animation.end }),
                            frameRate: animation.frameRate,
                            repeat: animation.repeat
                        })
                    }
                }

                // Input Events
                objects.cursors = this.input.keyboard.addKeys(keyboardKeys)

                // Some stars to collect, 12 in total, evenly spaced 70 pixels apart along the x axis
                objects.stars = this.physics.add.group(starSpecs)

                createStarChildrenModule(objects)

                // Bombs
                objects.bombs = this.physics.add.group();
                
                // The score
                objects.scoreText = this.add.text(texts.score.x, texts.score.y, texts.score.text, texts.score.font);

                // The stage
                objects.stageText = this.add.text(texts.stage.x, texts.stage.y, texts.stage.text, texts.stage.font);

                // Collide the player and the stars with the platforms
                this.physics.add.collider(objects.player, objects.platforms[objects.platformIndex]);
                this.physics.add.collider(objects.stars, objects.platforms[objects.platformIndex]);
                this.physics.add.collider(objects.bombs, objects.platforms[objects.platformIndex]);

                // Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
                this.physics.add.overlap(objects.player, objects.stars, collectStar, null, this);

                this.physics.add.collider(objects.player, objects.bombs, hitBomb, null, this);

                // Add joystick
                // TODO: Doesn't work as expected. It holds the pressed cursor but should do for now.
                this.joyStick = this.plugins.get('rexvirtualjoystickplugin').add(this, {
                    x: joystickSpecs.x,
                    y: joystickSpecs.y,
                    radius: joystickSpecs.radius,
                    base: this.add.circle(joystickSpecs.base.x, joystickSpecs.base.y, joystickSpecs.base.size, joystickSpecs.base.color),
                    thumb: this.add.circle(joystickSpecs.thumb.x, joystickSpecs.thumb.y, joystickSpecs.thumb.size, joystickSpecs.thumb.color),
                })
                    .on('update', joyStickState, this);

                // Setup instructions
                this.instructionsText = texts.instruction.text

                // Instructions
                objects.instructions = this.add.text(texts.instruction.x, texts.instruction.y, texts.instruction.text, texts.instruction.font);

                // // Start game with bomb
                createStartBombModule(objects)

                // Audio
                objects.sfx = this.cache.json.get('sfx');

                objects.music = this.sound.add('start');
                objects.music.play()
            }

            function update() {
                // Sounds
                if (objects.isMute) {
                    game.sound.mute = true;
                } else {
                    game.sound.mute = false;
                }

                if (objects.gameOver) {

                    objects.player.anims.play('explode');

                    console.log("game over")

                    $('#main').removeClass('hidden')
                    $('#main').addClass('z-10')
                    $('#game').addClass('game-over')

                    this.sound.playAudioSprite('sfx', 'alien death');

                    game.destroy()

                    return false
                }

                // Keyboard and mobile joystick
                if (objects.cursors.left.isDown || this.mobileCursorKeys === 'left') {
                    objects.player.setVelocityX(-160);

                    objects.player.anims.play('left', true);
                } else if (objects.cursors.right.isDown || this.mobileCursorKeys === 'right') {
                    objects.player.setVelocityX(160);

                    objects.player.anims.play('right', true);
                } else {
                    objects.player.setVelocityX(0);

                    objects.player.anims.play('turn');
                }

                if ((objects.cursors.up.isDown || this.mobileCursorKeys === 'up') && objects.player.body.touching.down) {
                    objects.player.setVelocityY(-330);
                    this.sound.playAudioSprite('sfx', 'squit');
                }
            }

            function joyStickState() {
                const cursorKeys = this.joyStick.createCursorKeys();
                for (const name in cursorKeys) {
                    if (cursorKeys[name].isDown) {
                        this.mobileCursorKeys = `${name}`
                    }
                }
            }

            function collectStar(player, star) {
                this.sound.playAudioSprite('sfx', 'ping');

                star.disableBody(true, true);

                // Add and update the score
                objects.score += 10;
                objects.scoreText.setText('Score: ' + objects.score);

                // Switch music when reaching stage 5
                if (objects.score === 600) {
                    objects.music.stop()

                    objects.music = this.sound.add('hard');
                    objects.music.play()
                }

                // Change background on score
                if ((objects.score % 360) === 0) {
                    this.sound.playAudioSprite('sfx', 'numkey');

                    // Platforms
                    objects.platforms[objects.platformIndex].clear(true, true);

                    objects.platformIndex++

                    // Reset background
                    if (objects.platformIndex === 4) {
                        objects.platformIndex = 1
                    }

                    changePlatform(objects.platformIndex)

                    // Reset colliders
                    // Collide the player and the stars with the platforms
                    this.physics.add.collider(player, objects.platforms[objects.platformIndex]);
                    this.physics.add.collider(objects.stars, objects.platforms[objects.platformIndex]);
                    this.physics.add.collider(objects.bombs, objects.platforms[objects.platformIndex]);

                    // Backgrounds
                    objects.skyIndex++

                    // Reset background
                    if (objects.skyIndex === 6) {
                        objects.skyIndex = 0
                    }

                    changeBackground(backgrounds[objects.skyIndex].key)

                    // Re add instructions
                    this.add.text(16, 560, this.instructionsText, { fontSize: '32px', fill: '#fff' });
                }

                if (objects.stars.countActive(true) === 0) {
                    // Update stage
                    objects.stageText.setText('Stage: ' + ++objects.stage);

                    // A new batch of stars to collect
                    objects.stars.children.iterate(function (child) {

                        child.enableBody(true, child.x, 0, true, true);

                    });

                    var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

                    var bomb = objects.bombs.create(x, 16, 'bomb');
                    bomb.setBounce(1);
                    bomb.setCollideWorldBounds(true);
                    bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
                    bomb.allowGravity = false;

                    this.sound.playAudioSprite('sfx', 'shot');
                }
            }

            function hitBomb(player, bomb) {
                this.physics.pause();

                bomb.destroy();

                objects.gameOver = true;
            }

            function changeBackground(key) {

                objects.sky.setTexture(key, 0);
            }

            function changePlatform(platformIndex) {

                // Default
                if (objects.platformIndex === 1) {

                    for (let [index, platform] of platforms.entries()) {
                        // Only get from first
                        if (index === 0) {

                            // Here we create the ground.
                            // Scale it to fit the width of the game (the original sprite is 400x32 in size)
                            for (const ground of platform.grounds) {
                                objects.platforms[objects.platformIndex].create(ground.x, ground.y, ground.key).setScale(2).refreshBody()
                            }

                            // Now let's create some ledges
                            for (const ledge of platform.ledges) {
                                objects.platforms[objects.platformIndex].create(ledge.x, ledge.y, ledge.key);
                            }

                            break
                        }
                    }
                } else if (objects.platformIndex === 2) {

                    for (let [index, platform] of platforms.entries()) {
                        console.log(index)
                        // Only get from first
                        if (index === 1) {
                            console.log('platform')
                            console.log(platform)

                            // Here we create the ground.
                            // Scale it to fit the width of the game (the original sprite is 400x32 in size)
                            for (const ground of platform.grounds) {
                                objects.platforms[objects.platformIndex].create(ground.x, ground.y, ground.key).setScale(2).refreshBody()
                            }

                            // Now let's create some ledges
                            for (const ledge of platform.ledges) {
                                objects.platforms[objects.platformIndex].create(ledge.x, ledge.y, ledge.key);
                            }

                            break;
                        }
                    }
                } else if (objects.platformIndex === 3) {

                    for (let [index, platform] of platforms.entries()) {
                        // Only get from first
                        if (index === 2) {

                            // Here we create the ground.
                            // Scale it to fit the width of the game (the original sprite is 400x32 in size)
                            for (const ground of platform.grounds) {
                                objects.platforms[objects.platformIndex].create(ground.x, ground.y, ground.key).setScale(2).refreshBody()
                            }

                            // Now let's create some ledges
                            for (const ledge of platform.ledges) {
                                objects.platforms[objects.platformIndex].create(ledge.x, ledge.y, ledge.key);
                            }

                            // Add bombs
                            for (const bomb of platform.bombs) {
                                objects.bombs.create(bomb.x, bomb.y, bomb.key).setImmovable(false).body.allowGravity = false;
                            }

                            break
                        }
                    }
                }

            }
        }


    </script>

</body>

</html>